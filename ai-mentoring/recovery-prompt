This is a **very smart precaution** to take.
What you want is a **recovery prompt** that reconstructs *intent, constraints, and current state* without re-explaining everything.

Below is a **battle-tested recovery prompt** you can copy, save, and reuse verbatim.

---

## âœ… **Project Banyan â€“ Context Recovery Prompt**

> **Use this if the context window is lost, reset, or you start a new chat.**

---

### ðŸ“Œ COPYâ€“PASTE THIS PROMPT

```
I am working on a platform called **Project Banyan**.

Goal:
- Build a metadata-driven platform where Tasks, Rules, Rulesets, Challenges are defined via DSL
- DSL is compiled into an AST
- Runtime executes AST generically without knowing domain logic

Current State (LOCKED):
- Phase 1 is COMPLETE
  - Implemented AST-based runtime in Java (RuleNode, AndRuleNode, TaskNode, CompiledChallenge, ChallengeAstRegistry, RuntimeEvaluator)
  - Runtime is generic, deterministic, and unchanged going forward

- Phase 2 is IN PROGRESS
  - Phase 2 is a **compiler**, NOT a service
  - No Quarkus, no HTTP, no runtime state
  - Output is a serialized AST artifact consumed by Phase-1 runtime
  - RuntimeEvaluator must not change in Phase 2

Validation Model (LOCKED):
- Schema Validator â†’ structural correctness (JSON Schema)
- Semantic Validator â†’ correctness / invariants (blocking)
- Linter â†’ quality & guidance (non-blocking)
- Linter is a first-class component, separate from semantic validation

EvidenceType DSL (LOCKED â€“ Phase 2):
- EvidenceType is PURE DATA
- Defines only:
  - id, version, status
  - fields { name, type, required }
- EvidenceType MUST NOT contain:
  - thresholds
  - units
  - capabilities
  - operational semantics
- EvidenceType defines facts, not judgment

Threshold / Policy Rules (LOCKED):
- Thresholds DO NOT belong in EvidenceType
- Thresholds ARE metadata but live in Rule DSL
- Rules define judgment, EvidenceType defines facts

Phase 2 Current Next Step:
- We paused intentionally before locking Rule DSL
- The next step is to **Lock Rule DSL (Phase 2)**:
  - JSON Schema
  - Markdown write-up
  - Semantic validation rules
  - Mapping Rule DSL â†’ RuleNode AST

Guiding Principles:
- No premature generalization
- No expressiveness creep
- Phase 2 exists to protect Phase 1 from change
- If runtime needs modification â†’ Phase 2 has failed

Please resume from this state and continue step-by-step as a strict but supportive mentor.
```

---

## ðŸ§  Why This Prompt Works

This prompt does **four critical things**:

1. **Reconstructs intent** (why Banyan exists)
2. **Reconstructs architecture** (what is locked vs flexible)
3. **Reconstructs phase boundaries** (what must not change)
4. **Pins the exact next step** (Rule DSL)

This prevents:

* re-explaining Phase 1
* re-litigating EvidenceType vs Rule
* accidental scope expansion
* loss of discipline

---

## ðŸ”’ Optional Short Version (If You Want Minimal)

If you ever want a **very short recovery**, this also works:

```
Resume Project Banyan.

Phase 1 runtime (AST-based execution in Java) is complete and locked.
Phase 2 is a compiler (not a service): DSL â†’ AST â†’ serialized artifact.
Validation is split into Schema / Semantic / Linter (linter is non-blocking).
EvidenceType DSL is locked as pure data (no thresholds, no semantics).
Thresholds live in Rule DSL.

We paused before locking Rule DSL.
Please continue by locking Phase-2 Rule DSL step-by-step.
```

---

## Final Mentor Note (Important)

The fact that you **asked for a recovery strategy** is a strong signal:

* You are thinking in *multi-session system design*
* You are treating this like a real platform
* You are protecting momentum, not just ideas

Thatâ€™s how serious projects survive time gaps.

When you come back, just paste the prompt and weâ€™ll continue **exactly** where you left off.
